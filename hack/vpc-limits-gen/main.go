// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"context"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"time"

	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	ec2types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
)

const fileTemplate = `// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// This file is generated via hack/vpc-limits-gen/main.go
// DO NOT EDIT directly. Run 'make generate-vpc-limits' to update.

// Code generated by go generate; DO NOT EDIT.
// This file was generated at %s

// WARNING: please add @ellistarn, @bwagner5, or @jonathan-innis from aws/karpenter to reviewers
// if you are updating this file since Karpenter is depending on this file to calculate max pods.

package vpc

type NetworkCard struct {
	// max number of interfaces supported per card
	MaximumNetworkInterfaces int64
	// the index of current card
	NetworkCardIndex   int64
	NetworkPerformance string
}

type VPCLimits struct {
	Interface               int
	IPv4PerInterface        int
	IsTrunkingCompatible    bool
	BranchInterface         int
	NetworkCards            []NetworkCard
	DefaultNetworkCardIndex int
	Hypervisor              string
	IsBareMetal             bool
	// Max pods calculation fields (using EKS AMI methodology)
	MaxPodsSecondaryIPs     int
	MaxPodsPrefixDelegation int
	MaxPodsRecommended      int
	CPUCount                int
}

// VPC Limits and flags for ENI and IPv4 Addresses
var Limits = map[string]*VPCLimits{
%s}
`

func main() {
	outputFile := flag.String("output", "pkg/aws/vpc/limits.go", "output file path")
	region := flag.String("region", "us-east-1", "AWS region to query")
	flag.Parse()

	ctx := context.Background()
	cfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(*region))
	if err != nil {
		log.Fatalf("unable to load SDK config: %v", err)
	}

	ec2Client := ec2.NewFromConfig(cfg)
	
	instanceTypes, err := getAllInstanceTypes(ctx, ec2Client)
	if err != nil {
		log.Fatalf("failed to get instance types: %v", err)
	}

	limitsMap := generateLimitsMap(instanceTypes)
	
	// Generate the file content
	timestamp := time.Now().UTC().Format(time.RFC3339)
	content := fmt.Sprintf(fileTemplate, timestamp, limitsMap)
	
	// Format the generated code
	formatted, err := format.Source([]byte(content))
	if err != nil {
		log.Fatalf("failed to format generated code: %v", err)
	}

	// Write to file
	if err := os.WriteFile(*outputFile, formatted, 0644); err != nil {
		log.Fatalf("failed to write output file: %v", err)
	}

	fmt.Printf("Successfully generated VPC limits file: %s\n", *outputFile)
}

func getAllInstanceTypes(ctx context.Context, client *ec2.Client) ([]ec2types.InstanceTypeInfo, error) {
	var allInstanceTypes []ec2types.InstanceTypeInfo
	params := &ec2.DescribeInstanceTypesInput{}

	for {
		result, err := client.DescribeInstanceTypes(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("failed to describe instance types: %w", err)
		}

		allInstanceTypes = append(allInstanceTypes, result.InstanceTypes...)

		if result.NextToken == nil {
			break
		}
		params.NextToken = result.NextToken
	}

	return allInstanceTypes, nil
}

func calculateMaxPodsSecondaryIPs(enis int, maxIPsPerENI int) int {
	// Formula from EKS AMI: ENIs * (MaxIPsPerENI - 1) + 2
	return enis*(maxIPsPerENI-1) + 2
}

func calculateMaxPodsPrefixDelegation(enis int, maxIPsPerENI int) int {
	// Formula from EKS AMI: ENIs * ((MaxIPsPerENI - 1) * 16) + 2
	// 16 IPs per prefix
	ipsPerPrefix := 16
	return enis*((maxIPsPerENI-1)*ipsPerPrefix) + 2
}

func calculateMaxPodsRecommended(maxPods int, cpuCount int) int {
	// CPU-based ceilings from EKS AMI
	maxPodCeilingLowCPU := 110
	maxPodCeilingHighCPU := 250
	
	var ceiling int
	if cpuCount > 30 {
		ceiling = maxPodCeilingHighCPU
	} else {
		ceiling = maxPodCeilingLowCPU
	}
	
	if maxPods < ceiling {
		return maxPods
	}
	return ceiling
}

func generateLimitsMap(instanceTypes []ec2types.InstanceTypeInfo) string {
	// Sort instance types by name for consistent output
	sort.Slice(instanceTypes, func(i, j int) bool {
		return string(instanceTypes[i].InstanceType) < string(instanceTypes[j].InstanceType)
	})

	var result string
	for _, info := range instanceTypes {
		name := string(info.InstanceType)
		
		// Get network info
		networkInfo := info.NetworkInfo
		if networkInfo == nil {
			continue
		}

		maxENIs := int(safeInt32Value(networkInfo.MaximumNetworkInterfaces))
		maxIPv4PerENI := int(safeInt32Value(networkInfo.Ipv4AddressesPerInterface))
		
		// Calculate branch interfaces for Nitro instances
		// Branch interfaces = (MaxENIs - 1) * (MaxIPv4PerENI - 1)
		isTrunking := isNitroInstance(info)
		branchInterfaces := 0
		if isTrunking && maxENIs > 0 {
			branchInterfaces = (maxENIs - 1) * (maxIPv4PerENI - 1)
		}

		// Get network cards info
		networkCards := generateNetworkCards(networkInfo.NetworkCards)
		defaultNetworkCardIndex := int(safeInt32Value(networkInfo.DefaultNetworkCardIndex))

		// Get hypervisor info
		hypervisor := ""
		if info.Hypervisor != "" {
			hypervisor = string(info.Hypervisor)
		}

		isBareMetal := info.BareMetal != nil && *info.BareMetal
		
		// Get CPU count
		cpuCount := int(safeInt32Value(info.VCpuInfo.DefaultVCpus))
		
		// Calculate max pods using EKS AMI methodology
		maxPodsSecondaryIPs := calculateMaxPodsSecondaryIPs(maxENIs, maxIPv4PerENI)
		// For prefix delegation: Nitro instances use 16 IPs per prefix, non-Nitro fall back to secondary IPs
		maxPodsPrefixDelegation := maxPodsSecondaryIPs
		if isTrunking {
			// Nitro instances can actually use prefix delegation
			maxPodsPrefixDelegation = calculateMaxPodsPrefixDelegation(maxENIs, maxIPv4PerENI)
		}
		
		// Calculate recommended max pods (with CPU ceiling)
		// For Nitro instances with prefix delegation support, use prefix delegation value
		// Otherwise use secondary IPs value
		baseMaxPods := maxPodsSecondaryIPs
		if isTrunking && maxPodsPrefixDelegation > 0 {
			baseMaxPods = maxPodsPrefixDelegation
		}
		maxPodsRecommended := calculateMaxPodsRecommended(baseMaxPods, cpuCount)

		result += fmt.Sprintf("\t\"%s\": {\n", name)
		result += fmt.Sprintf("\t\tInterface:               %d,\n", maxENIs)
		result += fmt.Sprintf("\t\tIPv4PerInterface:        %d,\n", maxIPv4PerENI)
		result += fmt.Sprintf("\t\tIsTrunkingCompatible:    %t,\n", isTrunking)
		result += fmt.Sprintf("\t\tBranchInterface:         %d,\n", branchInterfaces)
		result += fmt.Sprintf("\t\tDefaultNetworkCardIndex: %d,\n", defaultNetworkCardIndex)
		result += fmt.Sprintf("\t\tNetworkCards: []NetworkCard{\n")
		result += networkCards
		result += fmt.Sprintf("\t\t},\n")
		result += fmt.Sprintf("\t\tHypervisor:              \"%s\",\n", hypervisor)
		result += fmt.Sprintf("\t\tIsBareMetal:             %t,\n", isBareMetal)
		result += fmt.Sprintf("\t\tMaxPodsSecondaryIPs:     %d,\n", maxPodsSecondaryIPs)
		result += fmt.Sprintf("\t\tMaxPodsPrefixDelegation: %d,\n", maxPodsPrefixDelegation)
		result += fmt.Sprintf("\t\tMaxPodsRecommended:      %d,\n", maxPodsRecommended)
		result += fmt.Sprintf("\t\tCPUCount:                %d,\n", cpuCount)
		result += fmt.Sprintf("\t},\n")
	}

	return result
}

func generateNetworkCards(cards []ec2types.NetworkCardInfo) string {
	if len(cards) == 0 {
		return ""
	}

	var result string
	for _, card := range cards {
		result += fmt.Sprintf("\t\t\t{\n")
		result += fmt.Sprintf("\t\t\t\tMaximumNetworkInterfaces: %d,\n", safeInt32Value(card.MaximumNetworkInterfaces))
		result += fmt.Sprintf("\t\t\t\tNetworkCardIndex:         %d,\n", safeInt32Value(card.NetworkCardIndex))
		result += fmt.Sprintf("\t\t\t},\n")
		
		// Add blank line between cards if there are multiple
		if len(cards) > 1 && card.NetworkCardIndex != nil && *card.NetworkCardIndex < int32(len(cards)-1) {
			result += "\n"
		}
	}
	return result
}

func isNitroInstance(info ec2types.InstanceTypeInfo) bool {
	// Nitro instances have hypervisor type "nitro" or are bare metal
	if info.Hypervisor == "nitro" {
		return true
	}
	if info.BareMetal != nil && *info.BareMetal {
		return true
	}
	return false
}

func safeInt32Value(ptr *int32) int32 {
	if ptr == nil {
		return 0
	}
	return *ptr
}
